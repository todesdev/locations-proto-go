// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.1
// source: locations.proto

package locations

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LocationTypesServiceClient is the client API for LocationTypesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocationTypesServiceClient interface {
	GetAllLocationTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (LocationTypesService_GetAllLocationTypesClient, error)
	GetLocationTypeByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error)
	SearchLocationTypes(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (LocationTypesService_SearchLocationTypesClient, error)
	CreateLocationType(ctx context.Context, in *LocationTypeRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error)
	UpdateLocationType(ctx context.Context, in *UpdateLocationTypeRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error)
	DeleteLocationType(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error)
}

type locationTypesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLocationTypesServiceClient(cc grpc.ClientConnInterface) LocationTypesServiceClient {
	return &locationTypesServiceClient{cc}
}

func (c *locationTypesServiceClient) GetAllLocationTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (LocationTypesService_GetAllLocationTypesClient, error) {
	stream, err := c.cc.NewStream(ctx, &LocationTypesService_ServiceDesc.Streams[0], "/locations.LocationTypesService/GetAllLocationTypes", opts...)
	if err != nil {
		return nil, err
	}
	x := &locationTypesServiceGetAllLocationTypesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocationTypesService_GetAllLocationTypesClient interface {
	Recv() (*LocationTypeResponse, error)
	grpc.ClientStream
}

type locationTypesServiceGetAllLocationTypesClient struct {
	grpc.ClientStream
}

func (x *locationTypesServiceGetAllLocationTypesClient) Recv() (*LocationTypeResponse, error) {
	m := new(LocationTypeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *locationTypesServiceClient) GetLocationTypeByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error) {
	out := new(LocationTypeResponse)
	err := c.cc.Invoke(ctx, "/locations.LocationTypesService/GetLocationTypeByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationTypesServiceClient) SearchLocationTypes(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (LocationTypesService_SearchLocationTypesClient, error) {
	stream, err := c.cc.NewStream(ctx, &LocationTypesService_ServiceDesc.Streams[1], "/locations.LocationTypesService/SearchLocationTypes", opts...)
	if err != nil {
		return nil, err
	}
	x := &locationTypesServiceSearchLocationTypesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocationTypesService_SearchLocationTypesClient interface {
	Recv() (*LocationTypeResponse, error)
	grpc.ClientStream
}

type locationTypesServiceSearchLocationTypesClient struct {
	grpc.ClientStream
}

func (x *locationTypesServiceSearchLocationTypesClient) Recv() (*LocationTypeResponse, error) {
	m := new(LocationTypeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *locationTypesServiceClient) CreateLocationType(ctx context.Context, in *LocationTypeRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error) {
	out := new(LocationTypeResponse)
	err := c.cc.Invoke(ctx, "/locations.LocationTypesService/CreateLocationType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationTypesServiceClient) UpdateLocationType(ctx context.Context, in *UpdateLocationTypeRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error) {
	out := new(LocationTypeResponse)
	err := c.cc.Invoke(ctx, "/locations.LocationTypesService/UpdateLocationType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationTypesServiceClient) DeleteLocationType(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*LocationTypeResponse, error) {
	out := new(LocationTypeResponse)
	err := c.cc.Invoke(ctx, "/locations.LocationTypesService/DeleteLocationType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocationTypesServiceServer is the server API for LocationTypesService service.
// All implementations must embed UnimplementedLocationTypesServiceServer
// for forward compatibility
type LocationTypesServiceServer interface {
	GetAllLocationTypes(*emptypb.Empty, LocationTypesService_GetAllLocationTypesServer) error
	GetLocationTypeByPublicId(context.Context, *PublicIdRequest) (*LocationTypeResponse, error)
	SearchLocationTypes(*SearchRequest, LocationTypesService_SearchLocationTypesServer) error
	CreateLocationType(context.Context, *LocationTypeRequest) (*LocationTypeResponse, error)
	UpdateLocationType(context.Context, *UpdateLocationTypeRequest) (*LocationTypeResponse, error)
	DeleteLocationType(context.Context, *PublicIdRequest) (*LocationTypeResponse, error)
	mustEmbedUnimplementedLocationTypesServiceServer()
}

// UnimplementedLocationTypesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLocationTypesServiceServer struct {
}

func (UnimplementedLocationTypesServiceServer) GetAllLocationTypes(*emptypb.Empty, LocationTypesService_GetAllLocationTypesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllLocationTypes not implemented")
}
func (UnimplementedLocationTypesServiceServer) GetLocationTypeByPublicId(context.Context, *PublicIdRequest) (*LocationTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationTypeByPublicId not implemented")
}
func (UnimplementedLocationTypesServiceServer) SearchLocationTypes(*SearchRequest, LocationTypesService_SearchLocationTypesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchLocationTypes not implemented")
}
func (UnimplementedLocationTypesServiceServer) CreateLocationType(context.Context, *LocationTypeRequest) (*LocationTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLocationType not implemented")
}
func (UnimplementedLocationTypesServiceServer) UpdateLocationType(context.Context, *UpdateLocationTypeRequest) (*LocationTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLocationType not implemented")
}
func (UnimplementedLocationTypesServiceServer) DeleteLocationType(context.Context, *PublicIdRequest) (*LocationTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocationType not implemented")
}
func (UnimplementedLocationTypesServiceServer) mustEmbedUnimplementedLocationTypesServiceServer() {}

// UnsafeLocationTypesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocationTypesServiceServer will
// result in compilation errors.
type UnsafeLocationTypesServiceServer interface {
	mustEmbedUnimplementedLocationTypesServiceServer()
}

func RegisterLocationTypesServiceServer(s grpc.ServiceRegistrar, srv LocationTypesServiceServer) {
	s.RegisterService(&LocationTypesService_ServiceDesc, srv)
}

func _LocationTypesService_GetAllLocationTypes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocationTypesServiceServer).GetAllLocationTypes(m, &locationTypesServiceGetAllLocationTypesServer{stream})
}

type LocationTypesService_GetAllLocationTypesServer interface {
	Send(*LocationTypeResponse) error
	grpc.ServerStream
}

type locationTypesServiceGetAllLocationTypesServer struct {
	grpc.ServerStream
}

func (x *locationTypesServiceGetAllLocationTypesServer) Send(m *LocationTypeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LocationTypesService_GetLocationTypeByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationTypesServiceServer).GetLocationTypeByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.LocationTypesService/GetLocationTypeByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationTypesServiceServer).GetLocationTypeByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationTypesService_SearchLocationTypes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocationTypesServiceServer).SearchLocationTypes(m, &locationTypesServiceSearchLocationTypesServer{stream})
}

type LocationTypesService_SearchLocationTypesServer interface {
	Send(*LocationTypeResponse) error
	grpc.ServerStream
}

type locationTypesServiceSearchLocationTypesServer struct {
	grpc.ServerStream
}

func (x *locationTypesServiceSearchLocationTypesServer) Send(m *LocationTypeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LocationTypesService_CreateLocationType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationTypesServiceServer).CreateLocationType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.LocationTypesService/CreateLocationType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationTypesServiceServer).CreateLocationType(ctx, req.(*LocationTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationTypesService_UpdateLocationType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLocationTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationTypesServiceServer).UpdateLocationType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.LocationTypesService/UpdateLocationType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationTypesServiceServer).UpdateLocationType(ctx, req.(*UpdateLocationTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationTypesService_DeleteLocationType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationTypesServiceServer).DeleteLocationType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.LocationTypesService/DeleteLocationType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationTypesServiceServer).DeleteLocationType(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LocationTypesService_ServiceDesc is the grpc.ServiceDesc for LocationTypesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocationTypesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.LocationTypesService",
	HandlerType: (*LocationTypesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLocationTypeByPublicId",
			Handler:    _LocationTypesService_GetLocationTypeByPublicId_Handler,
		},
		{
			MethodName: "CreateLocationType",
			Handler:    _LocationTypesService_CreateLocationType_Handler,
		},
		{
			MethodName: "UpdateLocationType",
			Handler:    _LocationTypesService_UpdateLocationType_Handler,
		},
		{
			MethodName: "DeleteLocationType",
			Handler:    _LocationTypesService_DeleteLocationType_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllLocationTypes",
			Handler:       _LocationTypesService_GetAllLocationTypes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchLocationTypes",
			Handler:       _LocationTypesService_SearchLocationTypes_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// WorldRegionClustersServiceClient is the client API for WorldRegionClustersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorldRegionClustersServiceClient interface {
	GetAllWorldRegionClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (WorldRegionClustersService_GetAllWorldRegionClustersClient, error)
	GetWorldRegionClusterByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error)
	SearchWorldRegionClusters(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (WorldRegionClustersService_SearchWorldRegionClustersClient, error)
	CreateWorldRegionCluster(ctx context.Context, in *WorldRegionClusterRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error)
	UpdateWorldRegionCluster(ctx context.Context, in *UpdateWorldRegionClusterRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error)
	DeleteWorldRegionCluster(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error)
}

type worldRegionClustersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorldRegionClustersServiceClient(cc grpc.ClientConnInterface) WorldRegionClustersServiceClient {
	return &worldRegionClustersServiceClient{cc}
}

func (c *worldRegionClustersServiceClient) GetAllWorldRegionClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (WorldRegionClustersService_GetAllWorldRegionClustersClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorldRegionClustersService_ServiceDesc.Streams[0], "/locations.WorldRegionClustersService/GetAllWorldRegionClusters", opts...)
	if err != nil {
		return nil, err
	}
	x := &worldRegionClustersServiceGetAllWorldRegionClustersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorldRegionClustersService_GetAllWorldRegionClustersClient interface {
	Recv() (*WorldRegionClusterResponse, error)
	grpc.ClientStream
}

type worldRegionClustersServiceGetAllWorldRegionClustersClient struct {
	grpc.ClientStream
}

func (x *worldRegionClustersServiceGetAllWorldRegionClustersClient) Recv() (*WorldRegionClusterResponse, error) {
	m := new(WorldRegionClusterResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *worldRegionClustersServiceClient) GetWorldRegionClusterByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error) {
	out := new(WorldRegionClusterResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionClustersService/GetWorldRegionClusterByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionClustersServiceClient) SearchWorldRegionClusters(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (WorldRegionClustersService_SearchWorldRegionClustersClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorldRegionClustersService_ServiceDesc.Streams[1], "/locations.WorldRegionClustersService/SearchWorldRegionClusters", opts...)
	if err != nil {
		return nil, err
	}
	x := &worldRegionClustersServiceSearchWorldRegionClustersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorldRegionClustersService_SearchWorldRegionClustersClient interface {
	Recv() (*WorldRegionClusterResponse, error)
	grpc.ClientStream
}

type worldRegionClustersServiceSearchWorldRegionClustersClient struct {
	grpc.ClientStream
}

func (x *worldRegionClustersServiceSearchWorldRegionClustersClient) Recv() (*WorldRegionClusterResponse, error) {
	m := new(WorldRegionClusterResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *worldRegionClustersServiceClient) CreateWorldRegionCluster(ctx context.Context, in *WorldRegionClusterRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error) {
	out := new(WorldRegionClusterResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionClustersService/CreateWorldRegionCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionClustersServiceClient) UpdateWorldRegionCluster(ctx context.Context, in *UpdateWorldRegionClusterRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error) {
	out := new(WorldRegionClusterResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionClustersService/UpdateWorldRegionCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionClustersServiceClient) DeleteWorldRegionCluster(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionClusterResponse, error) {
	out := new(WorldRegionClusterResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionClustersService/DeleteWorldRegionCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorldRegionClustersServiceServer is the server API for WorldRegionClustersService service.
// All implementations must embed UnimplementedWorldRegionClustersServiceServer
// for forward compatibility
type WorldRegionClustersServiceServer interface {
	GetAllWorldRegionClusters(*emptypb.Empty, WorldRegionClustersService_GetAllWorldRegionClustersServer) error
	GetWorldRegionClusterByPublicId(context.Context, *PublicIdRequest) (*WorldRegionClusterResponse, error)
	SearchWorldRegionClusters(*SearchRequest, WorldRegionClustersService_SearchWorldRegionClustersServer) error
	CreateWorldRegionCluster(context.Context, *WorldRegionClusterRequest) (*WorldRegionClusterResponse, error)
	UpdateWorldRegionCluster(context.Context, *UpdateWorldRegionClusterRequest) (*WorldRegionClusterResponse, error)
	DeleteWorldRegionCluster(context.Context, *PublicIdRequest) (*WorldRegionClusterResponse, error)
	mustEmbedUnimplementedWorldRegionClustersServiceServer()
}

// UnimplementedWorldRegionClustersServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorldRegionClustersServiceServer struct {
}

func (UnimplementedWorldRegionClustersServiceServer) GetAllWorldRegionClusters(*emptypb.Empty, WorldRegionClustersService_GetAllWorldRegionClustersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllWorldRegionClusters not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) GetWorldRegionClusterByPublicId(context.Context, *PublicIdRequest) (*WorldRegionClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorldRegionClusterByPublicId not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) SearchWorldRegionClusters(*SearchRequest, WorldRegionClustersService_SearchWorldRegionClustersServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchWorldRegionClusters not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) CreateWorldRegionCluster(context.Context, *WorldRegionClusterRequest) (*WorldRegionClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorldRegionCluster not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) UpdateWorldRegionCluster(context.Context, *UpdateWorldRegionClusterRequest) (*WorldRegionClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorldRegionCluster not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) DeleteWorldRegionCluster(context.Context, *PublicIdRequest) (*WorldRegionClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorldRegionCluster not implemented")
}
func (UnimplementedWorldRegionClustersServiceServer) mustEmbedUnimplementedWorldRegionClustersServiceServer() {
}

// UnsafeWorldRegionClustersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorldRegionClustersServiceServer will
// result in compilation errors.
type UnsafeWorldRegionClustersServiceServer interface {
	mustEmbedUnimplementedWorldRegionClustersServiceServer()
}

func RegisterWorldRegionClustersServiceServer(s grpc.ServiceRegistrar, srv WorldRegionClustersServiceServer) {
	s.RegisterService(&WorldRegionClustersService_ServiceDesc, srv)
}

func _WorldRegionClustersService_GetAllWorldRegionClusters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorldRegionClustersServiceServer).GetAllWorldRegionClusters(m, &worldRegionClustersServiceGetAllWorldRegionClustersServer{stream})
}

type WorldRegionClustersService_GetAllWorldRegionClustersServer interface {
	Send(*WorldRegionClusterResponse) error
	grpc.ServerStream
}

type worldRegionClustersServiceGetAllWorldRegionClustersServer struct {
	grpc.ServerStream
}

func (x *worldRegionClustersServiceGetAllWorldRegionClustersServer) Send(m *WorldRegionClusterResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorldRegionClustersService_GetWorldRegionClusterByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionClustersServiceServer).GetWorldRegionClusterByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionClustersService/GetWorldRegionClusterByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionClustersServiceServer).GetWorldRegionClusterByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionClustersService_SearchWorldRegionClusters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorldRegionClustersServiceServer).SearchWorldRegionClusters(m, &worldRegionClustersServiceSearchWorldRegionClustersServer{stream})
}

type WorldRegionClustersService_SearchWorldRegionClustersServer interface {
	Send(*WorldRegionClusterResponse) error
	grpc.ServerStream
}

type worldRegionClustersServiceSearchWorldRegionClustersServer struct {
	grpc.ServerStream
}

func (x *worldRegionClustersServiceSearchWorldRegionClustersServer) Send(m *WorldRegionClusterResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorldRegionClustersService_CreateWorldRegionCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorldRegionClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionClustersServiceServer).CreateWorldRegionCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionClustersService/CreateWorldRegionCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionClustersServiceServer).CreateWorldRegionCluster(ctx, req.(*WorldRegionClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionClustersService_UpdateWorldRegionCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorldRegionClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionClustersServiceServer).UpdateWorldRegionCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionClustersService/UpdateWorldRegionCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionClustersServiceServer).UpdateWorldRegionCluster(ctx, req.(*UpdateWorldRegionClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionClustersService_DeleteWorldRegionCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionClustersServiceServer).DeleteWorldRegionCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionClustersService/DeleteWorldRegionCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionClustersServiceServer).DeleteWorldRegionCluster(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorldRegionClustersService_ServiceDesc is the grpc.ServiceDesc for WorldRegionClustersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorldRegionClustersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.WorldRegionClustersService",
	HandlerType: (*WorldRegionClustersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorldRegionClusterByPublicId",
			Handler:    _WorldRegionClustersService_GetWorldRegionClusterByPublicId_Handler,
		},
		{
			MethodName: "CreateWorldRegionCluster",
			Handler:    _WorldRegionClustersService_CreateWorldRegionCluster_Handler,
		},
		{
			MethodName: "UpdateWorldRegionCluster",
			Handler:    _WorldRegionClustersService_UpdateWorldRegionCluster_Handler,
		},
		{
			MethodName: "DeleteWorldRegionCluster",
			Handler:    _WorldRegionClustersService_DeleteWorldRegionCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllWorldRegionClusters",
			Handler:       _WorldRegionClustersService_GetAllWorldRegionClusters_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchWorldRegionClusters",
			Handler:       _WorldRegionClustersService_SearchWorldRegionClusters_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// WorldRegionsServiceClient is the client API for WorldRegionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorldRegionsServiceClient interface {
	GetAllWorldRegions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (WorldRegionsService_GetAllWorldRegionsClient, error)
	GetWorldRegionByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error)
	SearchWorldRegions(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (WorldRegionsService_SearchWorldRegionsClient, error)
	CreateWorldRegion(ctx context.Context, in *WorldRegionRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error)
	UpdateWorldRegion(ctx context.Context, in *UpdateWorldRegionRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error)
	DeleteWorldRegion(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error)
}

type worldRegionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorldRegionsServiceClient(cc grpc.ClientConnInterface) WorldRegionsServiceClient {
	return &worldRegionsServiceClient{cc}
}

func (c *worldRegionsServiceClient) GetAllWorldRegions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (WorldRegionsService_GetAllWorldRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorldRegionsService_ServiceDesc.Streams[0], "/locations.WorldRegionsService/GetAllWorldRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &worldRegionsServiceGetAllWorldRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorldRegionsService_GetAllWorldRegionsClient interface {
	Recv() (*WorldRegionResponse, error)
	grpc.ClientStream
}

type worldRegionsServiceGetAllWorldRegionsClient struct {
	grpc.ClientStream
}

func (x *worldRegionsServiceGetAllWorldRegionsClient) Recv() (*WorldRegionResponse, error) {
	m := new(WorldRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *worldRegionsServiceClient) GetWorldRegionByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error) {
	out := new(WorldRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionsService/GetWorldRegionByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionsServiceClient) SearchWorldRegions(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (WorldRegionsService_SearchWorldRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorldRegionsService_ServiceDesc.Streams[1], "/locations.WorldRegionsService/SearchWorldRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &worldRegionsServiceSearchWorldRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorldRegionsService_SearchWorldRegionsClient interface {
	Recv() (*WorldRegionResponse, error)
	grpc.ClientStream
}

type worldRegionsServiceSearchWorldRegionsClient struct {
	grpc.ClientStream
}

func (x *worldRegionsServiceSearchWorldRegionsClient) Recv() (*WorldRegionResponse, error) {
	m := new(WorldRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *worldRegionsServiceClient) CreateWorldRegion(ctx context.Context, in *WorldRegionRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error) {
	out := new(WorldRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionsService/CreateWorldRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionsServiceClient) UpdateWorldRegion(ctx context.Context, in *UpdateWorldRegionRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error) {
	out := new(WorldRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionsService/UpdateWorldRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *worldRegionsServiceClient) DeleteWorldRegion(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*WorldRegionResponse, error) {
	out := new(WorldRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.WorldRegionsService/DeleteWorldRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorldRegionsServiceServer is the server API for WorldRegionsService service.
// All implementations must embed UnimplementedWorldRegionsServiceServer
// for forward compatibility
type WorldRegionsServiceServer interface {
	GetAllWorldRegions(*emptypb.Empty, WorldRegionsService_GetAllWorldRegionsServer) error
	GetWorldRegionByPublicId(context.Context, *PublicIdRequest) (*WorldRegionResponse, error)
	SearchWorldRegions(*SearchRequest, WorldRegionsService_SearchWorldRegionsServer) error
	CreateWorldRegion(context.Context, *WorldRegionRequest) (*WorldRegionResponse, error)
	UpdateWorldRegion(context.Context, *UpdateWorldRegionRequest) (*WorldRegionResponse, error)
	DeleteWorldRegion(context.Context, *PublicIdRequest) (*WorldRegionResponse, error)
	mustEmbedUnimplementedWorldRegionsServiceServer()
}

// UnimplementedWorldRegionsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorldRegionsServiceServer struct {
}

func (UnimplementedWorldRegionsServiceServer) GetAllWorldRegions(*emptypb.Empty, WorldRegionsService_GetAllWorldRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllWorldRegions not implemented")
}
func (UnimplementedWorldRegionsServiceServer) GetWorldRegionByPublicId(context.Context, *PublicIdRequest) (*WorldRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorldRegionByPublicId not implemented")
}
func (UnimplementedWorldRegionsServiceServer) SearchWorldRegions(*SearchRequest, WorldRegionsService_SearchWorldRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchWorldRegions not implemented")
}
func (UnimplementedWorldRegionsServiceServer) CreateWorldRegion(context.Context, *WorldRegionRequest) (*WorldRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorldRegion not implemented")
}
func (UnimplementedWorldRegionsServiceServer) UpdateWorldRegion(context.Context, *UpdateWorldRegionRequest) (*WorldRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorldRegion not implemented")
}
func (UnimplementedWorldRegionsServiceServer) DeleteWorldRegion(context.Context, *PublicIdRequest) (*WorldRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorldRegion not implemented")
}
func (UnimplementedWorldRegionsServiceServer) mustEmbedUnimplementedWorldRegionsServiceServer() {}

// UnsafeWorldRegionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorldRegionsServiceServer will
// result in compilation errors.
type UnsafeWorldRegionsServiceServer interface {
	mustEmbedUnimplementedWorldRegionsServiceServer()
}

func RegisterWorldRegionsServiceServer(s grpc.ServiceRegistrar, srv WorldRegionsServiceServer) {
	s.RegisterService(&WorldRegionsService_ServiceDesc, srv)
}

func _WorldRegionsService_GetAllWorldRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorldRegionsServiceServer).GetAllWorldRegions(m, &worldRegionsServiceGetAllWorldRegionsServer{stream})
}

type WorldRegionsService_GetAllWorldRegionsServer interface {
	Send(*WorldRegionResponse) error
	grpc.ServerStream
}

type worldRegionsServiceGetAllWorldRegionsServer struct {
	grpc.ServerStream
}

func (x *worldRegionsServiceGetAllWorldRegionsServer) Send(m *WorldRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorldRegionsService_GetWorldRegionByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionsServiceServer).GetWorldRegionByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionsService/GetWorldRegionByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionsServiceServer).GetWorldRegionByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionsService_SearchWorldRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorldRegionsServiceServer).SearchWorldRegions(m, &worldRegionsServiceSearchWorldRegionsServer{stream})
}

type WorldRegionsService_SearchWorldRegionsServer interface {
	Send(*WorldRegionResponse) error
	grpc.ServerStream
}

type worldRegionsServiceSearchWorldRegionsServer struct {
	grpc.ServerStream
}

func (x *worldRegionsServiceSearchWorldRegionsServer) Send(m *WorldRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorldRegionsService_CreateWorldRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorldRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionsServiceServer).CreateWorldRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionsService/CreateWorldRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionsServiceServer).CreateWorldRegion(ctx, req.(*WorldRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionsService_UpdateWorldRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorldRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionsServiceServer).UpdateWorldRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionsService/UpdateWorldRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionsServiceServer).UpdateWorldRegion(ctx, req.(*UpdateWorldRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorldRegionsService_DeleteWorldRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorldRegionsServiceServer).DeleteWorldRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.WorldRegionsService/DeleteWorldRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorldRegionsServiceServer).DeleteWorldRegion(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorldRegionsService_ServiceDesc is the grpc.ServiceDesc for WorldRegionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorldRegionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.WorldRegionsService",
	HandlerType: (*WorldRegionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorldRegionByPublicId",
			Handler:    _WorldRegionsService_GetWorldRegionByPublicId_Handler,
		},
		{
			MethodName: "CreateWorldRegion",
			Handler:    _WorldRegionsService_CreateWorldRegion_Handler,
		},
		{
			MethodName: "UpdateWorldRegion",
			Handler:    _WorldRegionsService_UpdateWorldRegion_Handler,
		},
		{
			MethodName: "DeleteWorldRegion",
			Handler:    _WorldRegionsService_DeleteWorldRegion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllWorldRegions",
			Handler:       _WorldRegionsService_GetAllWorldRegions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchWorldRegions",
			Handler:       _WorldRegionsService_SearchWorldRegions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// CountriesServiceClient is the client API for CountriesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CountriesServiceClient interface {
	GetAllCountries(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CountriesService_GetAllCountriesClient, error)
	GetCountryByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryResponse, error)
	SearchCountries(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CountriesService_SearchCountriesClient, error)
	CreateCountry(ctx context.Context, in *CountryRequest, opts ...grpc.CallOption) (*CountryResponse, error)
	UpdateCountry(ctx context.Context, in *UpdateCountryRequest, opts ...grpc.CallOption) (*CountryResponse, error)
	DeleteCountry(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryResponse, error)
}

type countriesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCountriesServiceClient(cc grpc.ClientConnInterface) CountriesServiceClient {
	return &countriesServiceClient{cc}
}

func (c *countriesServiceClient) GetAllCountries(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CountriesService_GetAllCountriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CountriesService_ServiceDesc.Streams[0], "/locations.CountriesService/GetAllCountries", opts...)
	if err != nil {
		return nil, err
	}
	x := &countriesServiceGetAllCountriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CountriesService_GetAllCountriesClient interface {
	Recv() (*CountryResponse, error)
	grpc.ClientStream
}

type countriesServiceGetAllCountriesClient struct {
	grpc.ClientStream
}

func (x *countriesServiceGetAllCountriesClient) Recv() (*CountryResponse, error) {
	m := new(CountryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *countriesServiceClient) GetCountryByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryResponse, error) {
	out := new(CountryResponse)
	err := c.cc.Invoke(ctx, "/locations.CountriesService/GetCountryByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countriesServiceClient) SearchCountries(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CountriesService_SearchCountriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CountriesService_ServiceDesc.Streams[1], "/locations.CountriesService/SearchCountries", opts...)
	if err != nil {
		return nil, err
	}
	x := &countriesServiceSearchCountriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CountriesService_SearchCountriesClient interface {
	Recv() (*CountryResponse, error)
	grpc.ClientStream
}

type countriesServiceSearchCountriesClient struct {
	grpc.ClientStream
}

func (x *countriesServiceSearchCountriesClient) Recv() (*CountryResponse, error) {
	m := new(CountryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *countriesServiceClient) CreateCountry(ctx context.Context, in *CountryRequest, opts ...grpc.CallOption) (*CountryResponse, error) {
	out := new(CountryResponse)
	err := c.cc.Invoke(ctx, "/locations.CountriesService/CreateCountry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countriesServiceClient) UpdateCountry(ctx context.Context, in *UpdateCountryRequest, opts ...grpc.CallOption) (*CountryResponse, error) {
	out := new(CountryResponse)
	err := c.cc.Invoke(ctx, "/locations.CountriesService/UpdateCountry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countriesServiceClient) DeleteCountry(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryResponse, error) {
	out := new(CountryResponse)
	err := c.cc.Invoke(ctx, "/locations.CountriesService/DeleteCountry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CountriesServiceServer is the server API for CountriesService service.
// All implementations must embed UnimplementedCountriesServiceServer
// for forward compatibility
type CountriesServiceServer interface {
	GetAllCountries(*emptypb.Empty, CountriesService_GetAllCountriesServer) error
	GetCountryByPublicId(context.Context, *PublicIdRequest) (*CountryResponse, error)
	SearchCountries(*SearchRequest, CountriesService_SearchCountriesServer) error
	CreateCountry(context.Context, *CountryRequest) (*CountryResponse, error)
	UpdateCountry(context.Context, *UpdateCountryRequest) (*CountryResponse, error)
	DeleteCountry(context.Context, *PublicIdRequest) (*CountryResponse, error)
	mustEmbedUnimplementedCountriesServiceServer()
}

// UnimplementedCountriesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCountriesServiceServer struct {
}

func (UnimplementedCountriesServiceServer) GetAllCountries(*emptypb.Empty, CountriesService_GetAllCountriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllCountries not implemented")
}
func (UnimplementedCountriesServiceServer) GetCountryByPublicId(context.Context, *PublicIdRequest) (*CountryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCountryByPublicId not implemented")
}
func (UnimplementedCountriesServiceServer) SearchCountries(*SearchRequest, CountriesService_SearchCountriesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchCountries not implemented")
}
func (UnimplementedCountriesServiceServer) CreateCountry(context.Context, *CountryRequest) (*CountryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCountry not implemented")
}
func (UnimplementedCountriesServiceServer) UpdateCountry(context.Context, *UpdateCountryRequest) (*CountryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCountry not implemented")
}
func (UnimplementedCountriesServiceServer) DeleteCountry(context.Context, *PublicIdRequest) (*CountryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCountry not implemented")
}
func (UnimplementedCountriesServiceServer) mustEmbedUnimplementedCountriesServiceServer() {}

// UnsafeCountriesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CountriesServiceServer will
// result in compilation errors.
type UnsafeCountriesServiceServer interface {
	mustEmbedUnimplementedCountriesServiceServer()
}

func RegisterCountriesServiceServer(s grpc.ServiceRegistrar, srv CountriesServiceServer) {
	s.RegisterService(&CountriesService_ServiceDesc, srv)
}

func _CountriesService_GetAllCountries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CountriesServiceServer).GetAllCountries(m, &countriesServiceGetAllCountriesServer{stream})
}

type CountriesService_GetAllCountriesServer interface {
	Send(*CountryResponse) error
	grpc.ServerStream
}

type countriesServiceGetAllCountriesServer struct {
	grpc.ServerStream
}

func (x *countriesServiceGetAllCountriesServer) Send(m *CountryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CountriesService_GetCountryByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountriesServiceServer).GetCountryByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountriesService/GetCountryByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountriesServiceServer).GetCountryByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountriesService_SearchCountries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CountriesServiceServer).SearchCountries(m, &countriesServiceSearchCountriesServer{stream})
}

type CountriesService_SearchCountriesServer interface {
	Send(*CountryResponse) error
	grpc.ServerStream
}

type countriesServiceSearchCountriesServer struct {
	grpc.ServerStream
}

func (x *countriesServiceSearchCountriesServer) Send(m *CountryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CountriesService_CreateCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountriesServiceServer).CreateCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountriesService/CreateCountry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountriesServiceServer).CreateCountry(ctx, req.(*CountryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountriesService_UpdateCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCountryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountriesServiceServer).UpdateCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountriesService/UpdateCountry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountriesServiceServer).UpdateCountry(ctx, req.(*UpdateCountryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountriesService_DeleteCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountriesServiceServer).DeleteCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountriesService/DeleteCountry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountriesServiceServer).DeleteCountry(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CountriesService_ServiceDesc is the grpc.ServiceDesc for CountriesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CountriesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.CountriesService",
	HandlerType: (*CountriesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCountryByPublicId",
			Handler:    _CountriesService_GetCountryByPublicId_Handler,
		},
		{
			MethodName: "CreateCountry",
			Handler:    _CountriesService_CreateCountry_Handler,
		},
		{
			MethodName: "UpdateCountry",
			Handler:    _CountriesService_UpdateCountry_Handler,
		},
		{
			MethodName: "DeleteCountry",
			Handler:    _CountriesService_DeleteCountry_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllCountries",
			Handler:       _CountriesService_GetAllCountries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchCountries",
			Handler:       _CountriesService_SearchCountries_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// CountryRegionsServiceClient is the client API for CountryRegionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CountryRegionsServiceClient interface {
	GetAllCountryRegions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CountryRegionsService_GetAllCountryRegionsClient, error)
	GetCountryRegionByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error)
	GetCountryRegionsByCountryPublicId(ctx context.Context, in *CountryPublicIdRequest, opts ...grpc.CallOption) (CountryRegionsService_GetCountryRegionsByCountryPublicIdClient, error)
	SearchCountryRegions(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CountryRegionsService_SearchCountryRegionsClient, error)
	CreateCountryRegion(ctx context.Context, in *CountryRegionRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error)
	UpdateCountryRegion(ctx context.Context, in *UpdateCountryRegionRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error)
	DeleteCountryRegion(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error)
}

type countryRegionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCountryRegionsServiceClient(cc grpc.ClientConnInterface) CountryRegionsServiceClient {
	return &countryRegionsServiceClient{cc}
}

func (c *countryRegionsServiceClient) GetAllCountryRegions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CountryRegionsService_GetAllCountryRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &CountryRegionsService_ServiceDesc.Streams[0], "/locations.CountryRegionsService/GetAllCountryRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &countryRegionsServiceGetAllCountryRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CountryRegionsService_GetAllCountryRegionsClient interface {
	Recv() (*CountryRegionResponse, error)
	grpc.ClientStream
}

type countryRegionsServiceGetAllCountryRegionsClient struct {
	grpc.ClientStream
}

func (x *countryRegionsServiceGetAllCountryRegionsClient) Recv() (*CountryRegionResponse, error) {
	m := new(CountryRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *countryRegionsServiceClient) GetCountryRegionByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error) {
	out := new(CountryRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.CountryRegionsService/GetCountryRegionByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryRegionsServiceClient) GetCountryRegionsByCountryPublicId(ctx context.Context, in *CountryPublicIdRequest, opts ...grpc.CallOption) (CountryRegionsService_GetCountryRegionsByCountryPublicIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &CountryRegionsService_ServiceDesc.Streams[1], "/locations.CountryRegionsService/GetCountryRegionsByCountryPublicId", opts...)
	if err != nil {
		return nil, err
	}
	x := &countryRegionsServiceGetCountryRegionsByCountryPublicIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CountryRegionsService_GetCountryRegionsByCountryPublicIdClient interface {
	Recv() (*CountryRegionResponse, error)
	grpc.ClientStream
}

type countryRegionsServiceGetCountryRegionsByCountryPublicIdClient struct {
	grpc.ClientStream
}

func (x *countryRegionsServiceGetCountryRegionsByCountryPublicIdClient) Recv() (*CountryRegionResponse, error) {
	m := new(CountryRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *countryRegionsServiceClient) SearchCountryRegions(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CountryRegionsService_SearchCountryRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &CountryRegionsService_ServiceDesc.Streams[2], "/locations.CountryRegionsService/SearchCountryRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &countryRegionsServiceSearchCountryRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CountryRegionsService_SearchCountryRegionsClient interface {
	Recv() (*CountryRegionResponse, error)
	grpc.ClientStream
}

type countryRegionsServiceSearchCountryRegionsClient struct {
	grpc.ClientStream
}

func (x *countryRegionsServiceSearchCountryRegionsClient) Recv() (*CountryRegionResponse, error) {
	m := new(CountryRegionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *countryRegionsServiceClient) CreateCountryRegion(ctx context.Context, in *CountryRegionRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error) {
	out := new(CountryRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.CountryRegionsService/CreateCountryRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryRegionsServiceClient) UpdateCountryRegion(ctx context.Context, in *UpdateCountryRegionRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error) {
	out := new(CountryRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.CountryRegionsService/UpdateCountryRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *countryRegionsServiceClient) DeleteCountryRegion(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CountryRegionResponse, error) {
	out := new(CountryRegionResponse)
	err := c.cc.Invoke(ctx, "/locations.CountryRegionsService/DeleteCountryRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CountryRegionsServiceServer is the server API for CountryRegionsService service.
// All implementations must embed UnimplementedCountryRegionsServiceServer
// for forward compatibility
type CountryRegionsServiceServer interface {
	GetAllCountryRegions(*emptypb.Empty, CountryRegionsService_GetAllCountryRegionsServer) error
	GetCountryRegionByPublicId(context.Context, *PublicIdRequest) (*CountryRegionResponse, error)
	GetCountryRegionsByCountryPublicId(*CountryPublicIdRequest, CountryRegionsService_GetCountryRegionsByCountryPublicIdServer) error
	SearchCountryRegions(*SearchRequest, CountryRegionsService_SearchCountryRegionsServer) error
	CreateCountryRegion(context.Context, *CountryRegionRequest) (*CountryRegionResponse, error)
	UpdateCountryRegion(context.Context, *UpdateCountryRegionRequest) (*CountryRegionResponse, error)
	DeleteCountryRegion(context.Context, *PublicIdRequest) (*CountryRegionResponse, error)
	mustEmbedUnimplementedCountryRegionsServiceServer()
}

// UnimplementedCountryRegionsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCountryRegionsServiceServer struct {
}

func (UnimplementedCountryRegionsServiceServer) GetAllCountryRegions(*emptypb.Empty, CountryRegionsService_GetAllCountryRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllCountryRegions not implemented")
}
func (UnimplementedCountryRegionsServiceServer) GetCountryRegionByPublicId(context.Context, *PublicIdRequest) (*CountryRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCountryRegionByPublicId not implemented")
}
func (UnimplementedCountryRegionsServiceServer) GetCountryRegionsByCountryPublicId(*CountryPublicIdRequest, CountryRegionsService_GetCountryRegionsByCountryPublicIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCountryRegionsByCountryPublicId not implemented")
}
func (UnimplementedCountryRegionsServiceServer) SearchCountryRegions(*SearchRequest, CountryRegionsService_SearchCountryRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchCountryRegions not implemented")
}
func (UnimplementedCountryRegionsServiceServer) CreateCountryRegion(context.Context, *CountryRegionRequest) (*CountryRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCountryRegion not implemented")
}
func (UnimplementedCountryRegionsServiceServer) UpdateCountryRegion(context.Context, *UpdateCountryRegionRequest) (*CountryRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCountryRegion not implemented")
}
func (UnimplementedCountryRegionsServiceServer) DeleteCountryRegion(context.Context, *PublicIdRequest) (*CountryRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCountryRegion not implemented")
}
func (UnimplementedCountryRegionsServiceServer) mustEmbedUnimplementedCountryRegionsServiceServer() {}

// UnsafeCountryRegionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CountryRegionsServiceServer will
// result in compilation errors.
type UnsafeCountryRegionsServiceServer interface {
	mustEmbedUnimplementedCountryRegionsServiceServer()
}

func RegisterCountryRegionsServiceServer(s grpc.ServiceRegistrar, srv CountryRegionsServiceServer) {
	s.RegisterService(&CountryRegionsService_ServiceDesc, srv)
}

func _CountryRegionsService_GetAllCountryRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CountryRegionsServiceServer).GetAllCountryRegions(m, &countryRegionsServiceGetAllCountryRegionsServer{stream})
}

type CountryRegionsService_GetAllCountryRegionsServer interface {
	Send(*CountryRegionResponse) error
	grpc.ServerStream
}

type countryRegionsServiceGetAllCountryRegionsServer struct {
	grpc.ServerStream
}

func (x *countryRegionsServiceGetAllCountryRegionsServer) Send(m *CountryRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CountryRegionsService_GetCountryRegionByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryRegionsServiceServer).GetCountryRegionByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountryRegionsService/GetCountryRegionByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryRegionsServiceServer).GetCountryRegionByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryRegionsService_GetCountryRegionsByCountryPublicId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CountryPublicIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CountryRegionsServiceServer).GetCountryRegionsByCountryPublicId(m, &countryRegionsServiceGetCountryRegionsByCountryPublicIdServer{stream})
}

type CountryRegionsService_GetCountryRegionsByCountryPublicIdServer interface {
	Send(*CountryRegionResponse) error
	grpc.ServerStream
}

type countryRegionsServiceGetCountryRegionsByCountryPublicIdServer struct {
	grpc.ServerStream
}

func (x *countryRegionsServiceGetCountryRegionsByCountryPublicIdServer) Send(m *CountryRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CountryRegionsService_SearchCountryRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CountryRegionsServiceServer).SearchCountryRegions(m, &countryRegionsServiceSearchCountryRegionsServer{stream})
}

type CountryRegionsService_SearchCountryRegionsServer interface {
	Send(*CountryRegionResponse) error
	grpc.ServerStream
}

type countryRegionsServiceSearchCountryRegionsServer struct {
	grpc.ServerStream
}

func (x *countryRegionsServiceSearchCountryRegionsServer) Send(m *CountryRegionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CountryRegionsService_CreateCountryRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountryRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryRegionsServiceServer).CreateCountryRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountryRegionsService/CreateCountryRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryRegionsServiceServer).CreateCountryRegion(ctx, req.(*CountryRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryRegionsService_UpdateCountryRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCountryRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryRegionsServiceServer).UpdateCountryRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountryRegionsService/UpdateCountryRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryRegionsServiceServer).UpdateCountryRegion(ctx, req.(*UpdateCountryRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CountryRegionsService_DeleteCountryRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryRegionsServiceServer).DeleteCountryRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CountryRegionsService/DeleteCountryRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryRegionsServiceServer).DeleteCountryRegion(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CountryRegionsService_ServiceDesc is the grpc.ServiceDesc for CountryRegionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CountryRegionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.CountryRegionsService",
	HandlerType: (*CountryRegionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCountryRegionByPublicId",
			Handler:    _CountryRegionsService_GetCountryRegionByPublicId_Handler,
		},
		{
			MethodName: "CreateCountryRegion",
			Handler:    _CountryRegionsService_CreateCountryRegion_Handler,
		},
		{
			MethodName: "UpdateCountryRegion",
			Handler:    _CountryRegionsService_UpdateCountryRegion_Handler,
		},
		{
			MethodName: "DeleteCountryRegion",
			Handler:    _CountryRegionsService_DeleteCountryRegion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllCountryRegions",
			Handler:       _CountryRegionsService_GetAllCountryRegions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCountryRegionsByCountryPublicId",
			Handler:       _CountryRegionsService_GetCountryRegionsByCountryPublicId_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchCountryRegions",
			Handler:       _CountryRegionsService_SearchCountryRegions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// CitiesServiceClient is the client API for CitiesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CitiesServiceClient interface {
	GetAllCities(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CitiesService_GetAllCitiesClient, error)
	GetCityByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CityResponse, error)
	GetCitiesByCountryPublicId(ctx context.Context, in *CountryPublicIdRequest, opts ...grpc.CallOption) (CitiesService_GetCitiesByCountryPublicIdClient, error)
	SearchCities(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CitiesService_SearchCitiesClient, error)
	CreateCity(ctx context.Context, in *CityRequest, opts ...grpc.CallOption) (*CityResponse, error)
	UpdateCity(ctx context.Context, in *UpdateCityRequest, opts ...grpc.CallOption) (*CityResponse, error)
	DeleteCity(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CityResponse, error)
}

type citiesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCitiesServiceClient(cc grpc.ClientConnInterface) CitiesServiceClient {
	return &citiesServiceClient{cc}
}

func (c *citiesServiceClient) GetAllCities(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CitiesService_GetAllCitiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CitiesService_ServiceDesc.Streams[0], "/locations.CitiesService/GetAllCities", opts...)
	if err != nil {
		return nil, err
	}
	x := &citiesServiceGetAllCitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CitiesService_GetAllCitiesClient interface {
	Recv() (*CityResponse, error)
	grpc.ClientStream
}

type citiesServiceGetAllCitiesClient struct {
	grpc.ClientStream
}

func (x *citiesServiceGetAllCitiesClient) Recv() (*CityResponse, error) {
	m := new(CityResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *citiesServiceClient) GetCityByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CityResponse, error) {
	out := new(CityResponse)
	err := c.cc.Invoke(ctx, "/locations.CitiesService/GetCityByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *citiesServiceClient) GetCitiesByCountryPublicId(ctx context.Context, in *CountryPublicIdRequest, opts ...grpc.CallOption) (CitiesService_GetCitiesByCountryPublicIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &CitiesService_ServiceDesc.Streams[1], "/locations.CitiesService/GetCitiesByCountryPublicId", opts...)
	if err != nil {
		return nil, err
	}
	x := &citiesServiceGetCitiesByCountryPublicIdClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CitiesService_GetCitiesByCountryPublicIdClient interface {
	Recv() (*CityResponse, error)
	grpc.ClientStream
}

type citiesServiceGetCitiesByCountryPublicIdClient struct {
	grpc.ClientStream
}

func (x *citiesServiceGetCitiesByCountryPublicIdClient) Recv() (*CityResponse, error) {
	m := new(CityResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *citiesServiceClient) SearchCities(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (CitiesService_SearchCitiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CitiesService_ServiceDesc.Streams[2], "/locations.CitiesService/SearchCities", opts...)
	if err != nil {
		return nil, err
	}
	x := &citiesServiceSearchCitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CitiesService_SearchCitiesClient interface {
	Recv() (*CityResponse, error)
	grpc.ClientStream
}

type citiesServiceSearchCitiesClient struct {
	grpc.ClientStream
}

func (x *citiesServiceSearchCitiesClient) Recv() (*CityResponse, error) {
	m := new(CityResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *citiesServiceClient) CreateCity(ctx context.Context, in *CityRequest, opts ...grpc.CallOption) (*CityResponse, error) {
	out := new(CityResponse)
	err := c.cc.Invoke(ctx, "/locations.CitiesService/CreateCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *citiesServiceClient) UpdateCity(ctx context.Context, in *UpdateCityRequest, opts ...grpc.CallOption) (*CityResponse, error) {
	out := new(CityResponse)
	err := c.cc.Invoke(ctx, "/locations.CitiesService/UpdateCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *citiesServiceClient) DeleteCity(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*CityResponse, error) {
	out := new(CityResponse)
	err := c.cc.Invoke(ctx, "/locations.CitiesService/DeleteCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CitiesServiceServer is the server API for CitiesService service.
// All implementations must embed UnimplementedCitiesServiceServer
// for forward compatibility
type CitiesServiceServer interface {
	GetAllCities(*emptypb.Empty, CitiesService_GetAllCitiesServer) error
	GetCityByPublicId(context.Context, *PublicIdRequest) (*CityResponse, error)
	GetCitiesByCountryPublicId(*CountryPublicIdRequest, CitiesService_GetCitiesByCountryPublicIdServer) error
	SearchCities(*SearchRequest, CitiesService_SearchCitiesServer) error
	CreateCity(context.Context, *CityRequest) (*CityResponse, error)
	UpdateCity(context.Context, *UpdateCityRequest) (*CityResponse, error)
	DeleteCity(context.Context, *PublicIdRequest) (*CityResponse, error)
	mustEmbedUnimplementedCitiesServiceServer()
}

// UnimplementedCitiesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCitiesServiceServer struct {
}

func (UnimplementedCitiesServiceServer) GetAllCities(*emptypb.Empty, CitiesService_GetAllCitiesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllCities not implemented")
}
func (UnimplementedCitiesServiceServer) GetCityByPublicId(context.Context, *PublicIdRequest) (*CityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCityByPublicId not implemented")
}
func (UnimplementedCitiesServiceServer) GetCitiesByCountryPublicId(*CountryPublicIdRequest, CitiesService_GetCitiesByCountryPublicIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCitiesByCountryPublicId not implemented")
}
func (UnimplementedCitiesServiceServer) SearchCities(*SearchRequest, CitiesService_SearchCitiesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchCities not implemented")
}
func (UnimplementedCitiesServiceServer) CreateCity(context.Context, *CityRequest) (*CityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCity not implemented")
}
func (UnimplementedCitiesServiceServer) UpdateCity(context.Context, *UpdateCityRequest) (*CityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCity not implemented")
}
func (UnimplementedCitiesServiceServer) DeleteCity(context.Context, *PublicIdRequest) (*CityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCity not implemented")
}
func (UnimplementedCitiesServiceServer) mustEmbedUnimplementedCitiesServiceServer() {}

// UnsafeCitiesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CitiesServiceServer will
// result in compilation errors.
type UnsafeCitiesServiceServer interface {
	mustEmbedUnimplementedCitiesServiceServer()
}

func RegisterCitiesServiceServer(s grpc.ServiceRegistrar, srv CitiesServiceServer) {
	s.RegisterService(&CitiesService_ServiceDesc, srv)
}

func _CitiesService_GetAllCities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CitiesServiceServer).GetAllCities(m, &citiesServiceGetAllCitiesServer{stream})
}

type CitiesService_GetAllCitiesServer interface {
	Send(*CityResponse) error
	grpc.ServerStream
}

type citiesServiceGetAllCitiesServer struct {
	grpc.ServerStream
}

func (x *citiesServiceGetAllCitiesServer) Send(m *CityResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CitiesService_GetCityByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitiesServiceServer).GetCityByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CitiesService/GetCityByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitiesServiceServer).GetCityByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CitiesService_GetCitiesByCountryPublicId_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CountryPublicIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CitiesServiceServer).GetCitiesByCountryPublicId(m, &citiesServiceGetCitiesByCountryPublicIdServer{stream})
}

type CitiesService_GetCitiesByCountryPublicIdServer interface {
	Send(*CityResponse) error
	grpc.ServerStream
}

type citiesServiceGetCitiesByCountryPublicIdServer struct {
	grpc.ServerStream
}

func (x *citiesServiceGetCitiesByCountryPublicIdServer) Send(m *CityResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CitiesService_SearchCities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CitiesServiceServer).SearchCities(m, &citiesServiceSearchCitiesServer{stream})
}

type CitiesService_SearchCitiesServer interface {
	Send(*CityResponse) error
	grpc.ServerStream
}

type citiesServiceSearchCitiesServer struct {
	grpc.ServerStream
}

func (x *citiesServiceSearchCitiesServer) Send(m *CityResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CitiesService_CreateCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitiesServiceServer).CreateCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CitiesService/CreateCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitiesServiceServer).CreateCity(ctx, req.(*CityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CitiesService_UpdateCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitiesServiceServer).UpdateCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CitiesService/UpdateCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitiesServiceServer).UpdateCity(ctx, req.(*UpdateCityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CitiesService_DeleteCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitiesServiceServer).DeleteCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.CitiesService/DeleteCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitiesServiceServer).DeleteCity(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CitiesService_ServiceDesc is the grpc.ServiceDesc for CitiesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CitiesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.CitiesService",
	HandlerType: (*CitiesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCityByPublicId",
			Handler:    _CitiesService_GetCityByPublicId_Handler,
		},
		{
			MethodName: "CreateCity",
			Handler:    _CitiesService_CreateCity_Handler,
		},
		{
			MethodName: "UpdateCity",
			Handler:    _CitiesService_UpdateCity_Handler,
		},
		{
			MethodName: "DeleteCity",
			Handler:    _CitiesService_DeleteCity_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAllCities",
			Handler:       _CitiesService_GetAllCities_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCitiesByCountryPublicId",
			Handler:       _CitiesService_GetCitiesByCountryPublicId_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchCities",
			Handler:       _CitiesService_SearchCities_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}

// AddressesServiceClient is the client API for AddressesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AddressesServiceClient interface {
	GetAddressByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*AddressResponse, error)
	GetAddressesByPublicIds(ctx context.Context, in *AddressPublicIdsRequest, opts ...grpc.CallOption) (AddressesService_GetAddressesByPublicIdsClient, error)
	SearchAddresses(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (AddressesService_SearchAddressesClient, error)
	CreateAddress(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AddressResponse, error)
	UpdateAddress(ctx context.Context, in *UpdateAddressRequest, opts ...grpc.CallOption) (*AddressResponse, error)
	DeleteAddress(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*AddressResponse, error)
}

type addressesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAddressesServiceClient(cc grpc.ClientConnInterface) AddressesServiceClient {
	return &addressesServiceClient{cc}
}

func (c *addressesServiceClient) GetAddressByPublicId(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*AddressResponse, error) {
	out := new(AddressResponse)
	err := c.cc.Invoke(ctx, "/locations.AddressesService/GetAddressByPublicId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesServiceClient) GetAddressesByPublicIds(ctx context.Context, in *AddressPublicIdsRequest, opts ...grpc.CallOption) (AddressesService_GetAddressesByPublicIdsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AddressesService_ServiceDesc.Streams[0], "/locations.AddressesService/GetAddressesByPublicIds", opts...)
	if err != nil {
		return nil, err
	}
	x := &addressesServiceGetAddressesByPublicIdsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AddressesService_GetAddressesByPublicIdsClient interface {
	Recv() (*AddressResponse, error)
	grpc.ClientStream
}

type addressesServiceGetAddressesByPublicIdsClient struct {
	grpc.ClientStream
}

func (x *addressesServiceGetAddressesByPublicIdsClient) Recv() (*AddressResponse, error) {
	m := new(AddressResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *addressesServiceClient) SearchAddresses(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (AddressesService_SearchAddressesClient, error) {
	stream, err := c.cc.NewStream(ctx, &AddressesService_ServiceDesc.Streams[1], "/locations.AddressesService/SearchAddresses", opts...)
	if err != nil {
		return nil, err
	}
	x := &addressesServiceSearchAddressesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AddressesService_SearchAddressesClient interface {
	Recv() (*AddressResponse, error)
	grpc.ClientStream
}

type addressesServiceSearchAddressesClient struct {
	grpc.ClientStream
}

func (x *addressesServiceSearchAddressesClient) Recv() (*AddressResponse, error) {
	m := new(AddressResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *addressesServiceClient) CreateAddress(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*AddressResponse, error) {
	out := new(AddressResponse)
	err := c.cc.Invoke(ctx, "/locations.AddressesService/CreateAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesServiceClient) UpdateAddress(ctx context.Context, in *UpdateAddressRequest, opts ...grpc.CallOption) (*AddressResponse, error) {
	out := new(AddressResponse)
	err := c.cc.Invoke(ctx, "/locations.AddressesService/UpdateAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesServiceClient) DeleteAddress(ctx context.Context, in *PublicIdRequest, opts ...grpc.CallOption) (*AddressResponse, error) {
	out := new(AddressResponse)
	err := c.cc.Invoke(ctx, "/locations.AddressesService/DeleteAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AddressesServiceServer is the server API for AddressesService service.
// All implementations must embed UnimplementedAddressesServiceServer
// for forward compatibility
type AddressesServiceServer interface {
	GetAddressByPublicId(context.Context, *PublicIdRequest) (*AddressResponse, error)
	GetAddressesByPublicIds(*AddressPublicIdsRequest, AddressesService_GetAddressesByPublicIdsServer) error
	SearchAddresses(*SearchRequest, AddressesService_SearchAddressesServer) error
	CreateAddress(context.Context, *AddressRequest) (*AddressResponse, error)
	UpdateAddress(context.Context, *UpdateAddressRequest) (*AddressResponse, error)
	DeleteAddress(context.Context, *PublicIdRequest) (*AddressResponse, error)
	mustEmbedUnimplementedAddressesServiceServer()
}

// UnimplementedAddressesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAddressesServiceServer struct {
}

func (UnimplementedAddressesServiceServer) GetAddressByPublicId(context.Context, *PublicIdRequest) (*AddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressByPublicId not implemented")
}
func (UnimplementedAddressesServiceServer) GetAddressesByPublicIds(*AddressPublicIdsRequest, AddressesService_GetAddressesByPublicIdsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAddressesByPublicIds not implemented")
}
func (UnimplementedAddressesServiceServer) SearchAddresses(*SearchRequest, AddressesService_SearchAddressesServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchAddresses not implemented")
}
func (UnimplementedAddressesServiceServer) CreateAddress(context.Context, *AddressRequest) (*AddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddress not implemented")
}
func (UnimplementedAddressesServiceServer) UpdateAddress(context.Context, *UpdateAddressRequest) (*AddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAddress not implemented")
}
func (UnimplementedAddressesServiceServer) DeleteAddress(context.Context, *PublicIdRequest) (*AddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAddress not implemented")
}
func (UnimplementedAddressesServiceServer) mustEmbedUnimplementedAddressesServiceServer() {}

// UnsafeAddressesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AddressesServiceServer will
// result in compilation errors.
type UnsafeAddressesServiceServer interface {
	mustEmbedUnimplementedAddressesServiceServer()
}

func RegisterAddressesServiceServer(s grpc.ServiceRegistrar, srv AddressesServiceServer) {
	s.RegisterService(&AddressesService_ServiceDesc, srv)
}

func _AddressesService_GetAddressByPublicId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServiceServer).GetAddressByPublicId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.AddressesService/GetAddressByPublicId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServiceServer).GetAddressByPublicId(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressesService_GetAddressesByPublicIds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AddressPublicIdsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AddressesServiceServer).GetAddressesByPublicIds(m, &addressesServiceGetAddressesByPublicIdsServer{stream})
}

type AddressesService_GetAddressesByPublicIdsServer interface {
	Send(*AddressResponse) error
	grpc.ServerStream
}

type addressesServiceGetAddressesByPublicIdsServer struct {
	grpc.ServerStream
}

func (x *addressesServiceGetAddressesByPublicIdsServer) Send(m *AddressResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AddressesService_SearchAddresses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AddressesServiceServer).SearchAddresses(m, &addressesServiceSearchAddressesServer{stream})
}

type AddressesService_SearchAddressesServer interface {
	Send(*AddressResponse) error
	grpc.ServerStream
}

type addressesServiceSearchAddressesServer struct {
	grpc.ServerStream
}

func (x *addressesServiceSearchAddressesServer) Send(m *AddressResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AddressesService_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServiceServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.AddressesService/CreateAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServiceServer).CreateAddress(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressesService_UpdateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServiceServer).UpdateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.AddressesService/UpdateAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServiceServer).UpdateAddress(ctx, req.(*UpdateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressesService_DeleteAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServiceServer).DeleteAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/locations.AddressesService/DeleteAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServiceServer).DeleteAddress(ctx, req.(*PublicIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AddressesService_ServiceDesc is the grpc.ServiceDesc for AddressesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AddressesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "locations.AddressesService",
	HandlerType: (*AddressesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAddressByPublicId",
			Handler:    _AddressesService_GetAddressByPublicId_Handler,
		},
		{
			MethodName: "CreateAddress",
			Handler:    _AddressesService_CreateAddress_Handler,
		},
		{
			MethodName: "UpdateAddress",
			Handler:    _AddressesService_UpdateAddress_Handler,
		},
		{
			MethodName: "DeleteAddress",
			Handler:    _AddressesService_DeleteAddress_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAddressesByPublicIds",
			Handler:       _AddressesService_GetAddressesByPublicIds_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchAddresses",
			Handler:       _AddressesService_SearchAddresses_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "locations.proto",
}
